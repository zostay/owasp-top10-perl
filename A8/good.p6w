#!/usr/bin/env smackup
use v6;

# Very official secret updater thing
sub update-secret-data-for($name, $secret) {
    my $fh = "secrets/$name".IO.open(:r);
    $fh.say: $secret;
    $fh.close;
}

sub app(%env) {
    # Parse the parameters (naïvely)
    my $qs       = %env<QUERY_STRING>;
    my %params   = %env<p6w.input>.reduce({ $^a ~ $^b }).decode('UTF-8')\
                                 .split('&')».split('=').flat; # naïve
    my %session := %env<p6w.session>;

    # Make sure the user is logged in
    return 403, [ Content-type => 'text/plain' ], [ 'Not welcome.' ]
        unless %session<authorized-user>;

    # To start: check the origin/referrer
    return 403, [ Content-type => 'text/plain' ], [ 'Local edits only, please.' ]
        unless %env<HTTP_ORIGIN> | %env<HTTP_REFERER> eq 'https://foo'; # naïve

    # CSRF-specific auth: e.g., synchronizer token or double-submit cookie
    return 403, [ Content-type => 'text/plain' ], [ 'Tricksy! False! Bad Hobbitses!' ]
        unless %params<token> eq %session<token>;

    # Prefer body-parameters, to limit these to POST body
    my $name   = %params<name>;
    $name ~~ /^ <[ a..z A..Z ]>+ $/
        or return 400, [ 'Content-type' => 'text/plain' ], [ 'Letters only, you.' ];

    my $secret = %parameters<secret>;
    $secret =~ /^ <[ a..z A..Z \s ]>+ $/
        or return 400, [ 'Content-type' => 'text/plain' ], [ 'Your secret is too complicated.' ];

    # Make sure the user is allowed to do this
    return 403, [ 'Content-type' => 'text/plain' ], [ 'Not the one.' ]
        unless %session<user-name> = $name;

    # Update is safe from CSRF
    update-secret-data-for($name, $secret);

    200, [ 'Content-type' => 'text/plain' ], [ 'Secret updated.' ];
}

# vim: ft=perl6 ts=4 sw=4 sts=4
